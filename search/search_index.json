{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Workshop CFDSUSTAIN - OpenLB","text":""},{"location":"cavidade2d/01-problema/","title":"Problema de Cavidade Quadrada","text":"<p>O problema da cavidade quadrada (lid\u2011driven cavity) \u00e9 um caso\u2011teste cl\u00e1ssico em din\u00e2mica dos fluidos computacional (CFD). </p> <p>Um fluido incompress\u00edvel e Newtoniano \u00e9 confinado em uma cavidade quadrada de paredes r\u00edgidas; somente a tampa superior se move com velocidade constante \\(U_{\\text{lid}}\\), arrastando o fluido e gerando uma estrutura de v\u00f3rtices caracter\u00edstica cujo desenvolvimento depende essencialmente do n\u00famero de Reynolds.</p> <p></p>"},{"location":"cavidade2d/01-problema/#condicoes-de-contorno","title":"Condi\u00e7\u00f5es de contorno","text":"Parede Velocidade prescrita Observa\u00e7\u00e3o Tampa U,V= (1\u202fm/s,\u00a00) Lid\u2011driven Laterais e base U,V = (0,\u202f0) N\u00e3o\u2011deslizamento <ul> <li>Comprimento caracter\u00edstico: \\(L = 1\\,\\text{m}\\)</li> <li>Massa espec\u00edfica: \\(\\rho = 1\\,\\text{kg/m\u00b3}\\)</li> <li>Viscosidade cinem\u00e1tica \\(\\nu\\) vari\u00e1vel</li> </ul> <p>O n\u00famero de Reynolds \u00e9 dado por:</p> \\[   Re = \\frac{L\\,U_{\\text{lid}}}{\\nu}. \\]"},{"location":"cavidade2d/02-compilar-executar/","title":"Compila\u00e7\u00e3o e Execu\u00e7\u00e3o","text":"<p>Limpeza e build</p> <pre><code>cd examples/forBegginers/cavity2d\nmake clean &amp;&amp; make\n</code></pre> <p>Execu\u00e7\u00e3o em 2 processos MPI</p> <pre><code>mpirun -np 2 cavity2d      # ou mpiexec conforme seu ambiente\n</code></pre> <p>Os resultados VTK ser\u00e3o escritos em <code>tmp/vtkData/cavity2d/</code>.</p>"},{"location":"cavidade2d/02-compilar-executar/#visualizacao-no-paraview","title":"Visualiza\u00e7\u00e3o no ParaView","text":"<ol> <li>Abra ParaView \u2192 File \u25b8 Open \u2192 <code>cavity2d.pvd</code>.</li> <li>Clique Apply e pressione Play na timeline.</li> </ol>"},{"location":"cavidade2d/03-parametros/","title":"Estudo de Par\u00e2metros (Reynolds)","text":"<p>Altere a viscosidade em <code>cavity2d.cpp</code>:</p> Trecho relevante<pre><code>const T physViscosity = 0.001;  // exemplo: Re \u2248 100\n</code></pre> Note <p>Lembre-se que  $$ Re = \\frac{L\\,U_{\\text{lid}}}{\\nu}. $$</p> Caso \\(\\nu\\)\u00a0(m\u00b2/s) \\(Re\\) esperado Observa\u00e7\u00e3o A 0.001 1000 Solu\u00e7\u00e3o est\u00e1vel B 1e\u20114 1\u00d710\u2074 Instabilidade num\u00e9rica <p>Recompilar e rodar</p> <pre><code>make &amp;&amp; mpirun -np 2 cavity2d\n</code></pre> <p>Para \\(Re = 10^4\\) o c\u00f3digo diverge. Veja Diagn\u00f3sticos para estrat\u00e9gias de estabilidade.</p>"},{"location":"cavidade2d/05-diagnosticos/","title":"Diagn\u00f3sticos de Estabilidade","text":"<p>Reynolds muito alto \u2192 use resolu\u00e7\u00e3o maior. Frequ\u00eancia de relaxa\u00e7\u00e3o  </p> \\[   \\omega = \\frac{1}{3\\,\\nu + 0.5}   \\] <p>e  $$ CFL = \\frac{u * \\delta{t}}{\\delta{x}} $$</p> <p>Deve obedecer \\(0 &lt; \\omega &lt; 2\\), onde \\(c_s = 1/\\sqrt{3}\\).</p> Siga a mensagem de erro <p></p>"},{"location":"cilindro2d/","title":"Exemplo Cilindro\u00a02\u202fD \u2013 Vis\u00e3o Geral","text":"<p>Este m\u00f3dulo explora um escoamento laminar em torno de um cilindro dentro de um canal 2\u202fD, inspirado no benchmark de Sch\u00e4fer\u00a0&amp;\u00a0Turek.</p> <p>Objetivos:</p> <ol> <li>Entender como renomear materiais e aplicar diferentes condi\u00e7\u00f5es de contorno no OpenLB.  </li> <li>Medir a queda de press\u00e3o ao redor do obst\u00e1culo e estud\u00e1\u2011la para v\u00e1rios raios.  </li> <li>Substituir o cilindro por outros objetos e comparar os resultados.</li> </ol> <p></p>"},{"location":"cilindro2d/geometria/","title":"2\u00a0\u00b7\u00a0Geometria do Problema","text":"<p>Par\u00e2metros em unidades SI:</p> <pre><code>const T lengthX = 2.2;              // m\nconst T lengthY = 0.41 + L;         // m\nconst T centerCylinderX = 0.2;      // m\nconst T centerCylinderY = 0.2 + L/2.; \nconst T radiusCylinder  = 0.05;     // m\n</code></pre> <p>O perfil de velocidade na entrada \u00e9 um Poiseuille com \\(u_{max}=0.2\\)   m\u00b7s\u207b\u00b9, resultando em \\(Re = 20\\).</p>"},{"location":"cilindro2d/geometria/#esquema","title":"Esquema","text":""},{"location":"cilindro2d/geometria/#exemplo-de-solucao-esperada","title":"Exemplo de Solu\u00e7\u00e3o esperada","text":""},{"location":"cilindro2d/original/","title":"C\u00f3digo Original","text":"<pre><code>/*  Lattice Boltzmann sample, written in C++, using the OpenLB library\n *\n *  Copyright (C) 2006-2025 Fedor Bukreev, Shota Ito,\n *  Jonas Latt, Mathias J. Krause, Vojtech Cvrcek,\n *  Peter Weisbrod, Adrian Kummerl\u00e4nder\n *  E-mail contact: info@openlb.net\n *  The most recent release of OpenLB can be downloaded at\n *  &lt;http://www.openlb.net/&gt;\n *\n *  This program is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU General Public License\n *  as published by the Free Software Foundation; either version 2\n *  of the License, or (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public\n *  License along with this program; if not, write to the Free\n *  Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n *  Boston, MA  02110-1301, USA.\n */\n\n/* cylinder2d.h:\n * This example examines a steady flow past a cylinder placed in a channel.\n * The cylinder is offset somewhat from the center of the flow to make the\n * steady-state symmetrical flow unstable. At the inlet, a Poiseuille profile is\n * imposed on the velocity, whereas the outlet implements a Dirichlet pressure\n * condition set by p = 0.\n * Inspired by \"Benchmark Computations of Laminar Flow Around\n * a Cylinder\" by M.Sch\u00e4fer and S.Turek.\n * An unsteady flow with Karman vortex street can be created by changing the\n * Reynolds number to Re=100.\n */\n\n#include &lt;olb.h&gt;\n\nusing namespace olb;\n\nusing T = FLOATING_POINT_TYPE;\nusing DESCRIPTOR = descriptors::D2Q9&lt;&gt;;\n\n// Parameters for the simulation setup\nconst int N = 10;       // resolution of the model\nconst T CFL = 0.05;     // characteristic CFL number\nconst T Re = 20.;       // Reynolds number\nconst T maxPhysT = 16;  // max. simulation time in s, SI unit\nconst T L = 0.1/N;      // latticeL\nconst T lengthX = 2.2;\nconst T lengthY = .41+L;\nconst T centerCylinderX = 0.2;\nconst T centerCylinderY = 0.2+L/2.;\nconst T radiusCylinder = 0.05;\n\n// Stores geometry information in form of material numbers\nvoid prepareGeometry(const UnitConverter&lt;T,DESCRIPTOR&gt;&amp; converter,\n                     SuperGeometry&lt;T,2&gt;&amp; superGeometry,\n                     IndicatorF2D&lt;T&gt;&amp; circle)\n{\n  Vector&lt;T,2&gt; extend(lengthX, lengthY);\n  Vector&lt;T,2&gt; origin;\n  superGeometry.rename(0, 2);\n  superGeometry.rename(2, 1, {1,1});\n\n  // Set material number for inflow\n  extend[0] = 2.*L;\n  origin[0] = -L;\n  IndicatorCuboid2D&lt;T&gt; inflow(extend, origin);\n  superGeometry.rename(2, 3, 1, inflow);\n\n  // Set material number for outflow\n  origin[0] = lengthX - L;\n  IndicatorCuboid2D&lt;T&gt; outflow(extend, origin);\n  superGeometry.rename(2, 4, 1, outflow);\n\n  // Set material number for cylinder\n  superGeometry.rename(1, 5, circle);\n\n  // Removes all not needed boundary voxels outside the surface\n  superGeometry.clean();\n  superGeometry.checkForErrors();\n  superGeometry.print();\n}\n\n// Set up the geometry of the simulation\nvoid prepareLattice(SuperLattice&lt;T,DESCRIPTOR&gt;&amp; sLattice,\n                    const UnitConverter&lt;T, DESCRIPTOR&gt;&amp; converter,\n                    SuperGeometry&lt;T,2&gt;&amp; superGeometry,\n                    IndicatorF2D&lt;T&gt;&amp; circle)\n{\n  // Material=1 --&gt;bulk dynamics\n  sLattice.defineDynamics&lt;BGKdynamics&gt;(superGeometry, 1);\n\n  // Material=2 --&gt;bounce back\n  boundary::set&lt;boundary::BounceBack&gt;(sLattice, superGeometry, 2);\n\n  // Material=3 --&gt;fixed velocity\n  boundary::set&lt;boundary::InterpolatedVelocity&gt;(sLattice, superGeometry, 3);\n\n  // Material=4 --&gt;fixed pressure\n  boundary::set&lt;boundary::InterpolatedPressure&gt;(sLattice, superGeometry, 4);\n\n  // Material=5 --&gt;bouzidi\n  setBouzidiBoundary(sLattice, superGeometry, 5, circle);\n\n  // Initial conditions\n  AnalyticalConst2D&lt;T,T&gt; rhoF(1);\n  AnalyticalConst2D&lt;T,T&gt; uF(0, 0);\n\n  // Initialize all values of distribution functions to their local equilibrium\n  sLattice.defineRhoU(superGeometry, 1, rhoF, uF);\n  sLattice.iniEquilibrium(superGeometry, 1, rhoF, uF);\n  sLattice.setParameter&lt;descriptors::OMEGA&gt;(converter.getLatticeRelaxationFrequency());\n  sLattice.initialize();\n}\n\n// Generates a slowly increasing inflow for the first iTMaxStart timesteps\nvoid setBoundaryValues(SuperLattice&lt;T, DESCRIPTOR&gt;&amp; sLattice,\n                       const UnitConverter&lt;T, DESCRIPTOR&gt;&amp; converter, std::size_t iT,\n                       SuperGeometry&lt;T,2&gt;&amp; superGeometry)\n{\n  // Number of time steps for smooth start-up\n  const std::size_t iTmaxStart = converter.getLatticeTime( maxPhysT*0.4 );\n  const std::size_t iTupdate = iTmaxStart/1000;\n\n  if ( iT%iTupdate==0 &amp;&amp; iT&lt;= iTmaxStart ) {\n    // Smooth start curve, polynomial\n    PolynomialStartScale&lt;T,T&gt; StartScale( iTmaxStart, T( 1 ) );\n\n    // Creates and sets the Poiseuille inflow profile using functors\n    T iTvec[1] = {T( iT )};\n    T frac[1] = {};\n    StartScale( frac,iTvec );\n    T maxVelocity = converter.getCharLatticeVelocity()*3./2.*frac[0];\n    T distance2Wall = L/2.;\n    Poiseuille2D&lt;T&gt; poiseuilleU( superGeometry, 3, maxVelocity, distance2Wall );\n    sLattice.defineU( superGeometry, 3, poiseuilleU );\n\n    // Update velocity on GPU\n    sLattice.setProcessingContext&lt;Array&lt;momenta::FixedVelocityMomentumGeneric::VELOCITY&gt;&gt;(\n      ProcessingContext::Simulation);\n  }\n}\n\n// Computes the pressure drop between the voxels before and after the cylinder\nvoid getResults(SuperLattice&lt;T, DESCRIPTOR&gt;&amp; sLattice,\n                const UnitConverter&lt;T, DESCRIPTOR&gt;&amp; converter, std::size_t iT,\n                SuperGeometry&lt;T,2&gt;&amp; superGeometry, util::Timer&lt;T&gt;&amp; timer)\n{\n  OstreamManager clout( std::cout,\"getResults\" );\n  const std::size_t vtkIter  = converter.getLatticeTime(0.3);\n  const std::size_t statIter = converter.getLatticeTime(0.8);\n\n  SuperVTMwriter2D&lt;T&gt; vtmWriter(\"cylinder2d\");\n  SuperLatticePhysVelocity2D&lt;T,DESCRIPTOR&gt; velocity(sLattice, converter);\n  SuperLatticePhysPressure2D&lt;T,DESCRIPTOR&gt; pressure(sLattice, converter);\n  vtmWriter.addFunctor(velocity);\n  vtmWriter.addFunctor(pressure);\n\n  if (iT == 0) {\n    vtmWriter.createMasterFile();\n  }\n\n  // Writes the vtk files\n  if (iT%vtkIter == 0 &amp;&amp; iT &gt; 0) {\n    // Send values from GPU to CPU for evaluation\n    sLattice.setProcessingContext(ProcessingContext::Evaluation);\n    vtmWriter.write(iT);\n  }\n\n  // Writes the console log\n  if (iT%statIter == 0) {\n    // Send values from GPU to CPU for evaluation\n    sLattice.setProcessingContext(ProcessingContext::Evaluation);\n\n    // Timer console output\n    timer.update(iT);\n    timer.printStep();\n    sLattice.getStatistics().print(iT,converter.getPhysTime(iT));\n\n    // Pressure drop\n    AnalyticalFfromSuperF2D&lt;T&gt; intpolatePressure( pressure, true );\n\n    T point1[2] = {};\n    T point2[2] = {};\n\n    point1[0] = centerCylinderX - radiusCylinder;\n    point1[1] = centerCylinderY;\n\n    point2[0] = centerCylinderX + radiusCylinder;\n    point2[1] = centerCylinderY;\n\n    T p1, p2;\n    intpolatePressure( &amp;p1,point1 );\n    intpolatePressure( &amp;p2,point2 );\n\n    clout &lt;&lt; \"pressure1=\" &lt;&lt; p1;\n    clout &lt;&lt; \"; pressure2=\" &lt;&lt; p2;\n\n    T pressureDrop = p1-p2;\n    clout &lt;&lt; \"; pressureDrop=\" &lt;&lt; pressureDrop &lt;&lt; std::endl;\n  }\n\n}\n\nint main(int argc, char* argv[])\n{\n  // === 1st Step: Initialization ===\n  initialize(&amp;argc, &amp;argv);\n  OstreamManager clout(std::cout, \"main\");\n\n  // Set up the unit converter\n  const UnitConverter&lt;T,DESCRIPTOR&gt; converter(\n    (T)   L,                        // physDeltaX: spacing between two lattice cells in [m]\n    (T)   CFL*L/0.2,                // physDeltaT: time step in [s]\n    (T)   2.0*radiusCylinder,       // charPhysLength: reference length of simulation geometry in [m]\n    (T)   0.2,                      // charPhysVelocity: highest expected velocity during simulation in [m/s]\n    (T)   0.2*2.*radiusCylinder/Re, // physViscosity: physical kinematic viscosity in [m^2/s]\n    (T)   1.0                       // physDensity: physical density in [kg/m^3]\n  );\n  converter.print();\n\n  // === 2rd Step: Prepare Geometry ===\n  Vector extend{lengthX, lengthY};\n  Vector origin{0, 0};\n  IndicatorCuboid2D&lt;T&gt; cuboid(extend, origin);\n  CuboidDecomposition2D&lt;T&gt; cuboidDecomposition(cuboid, L, singleton::mpi().getSize());\n\n  HeuristicLoadBalancer&lt;T&gt; loadBalancer(cuboidDecomposition);\n\n  SuperGeometry&lt;T,2&gt; superGeometry(cuboidDecomposition, loadBalancer);\n  Vector center{centerCylinderX, centerCylinderY};\n  IndicatorCircle2D&lt;T&gt; circle(center, radiusCylinder);\n  prepareGeometry(converter, superGeometry, circle);\n\n  // === 3rd Step: Prepare Lattice ===\n  SuperLattice&lt;T,DESCRIPTOR&gt; sLattice(superGeometry);\n  prepareLattice(sLattice, converter, superGeometry, circle);\n\n  // === 4th Step: Main Loop with Timer ===\n  std::size_t iTmax = converter.getLatticeTime(maxPhysT);\n  util::Timer&lt;T&gt; timer(iTmax, superGeometry.getStatistics().getNvoxel());\n  timer.start();\n\n  for (std::size_t iT = 0; iT &lt; iTmax; ++iT) {\n    // === 5th Step: Definition of Initial and Boundary Conditions ===\n    setBoundaryValues(sLattice, converter, iT, superGeometry);\n    // === 6th Step: Collide and Stream Execution ===\n    sLattice.collideAndStream();\n    // === 7th Step: Computation and Output of the Results ===\n    getResults(sLattice, converter, iT, superGeometry, timer);\n  }\n\n  timer.stop();\n  timer.printSummary();\n}\n</code></pre>"},{"location":"cilindro2d/tarefa1/","title":"Tarefa 1","text":""},{"location":"cilindro2d/tarefa1/#passo-1-executar-caso-base-cilindro-r-005-m","title":"Passo 1 \u00b7 Executar Caso-Base (cilindro, r = 0.05 m)","text":"<pre><code>cd $OLB_ROOT/examples/forBeginners/cylinder2d\nmake clean &amp;&amp; make\nmpirun -np 4 ./cylinder2d\n</code></pre> <p>Exemplo de sa\u00edda:</p> <pre><code>[getResults] pressure1=0.126632; pressure2=0.0049181; pressureDrop=0.121714\n</code></pre>"},{"location":"cilindro2d/tarefa1/#passo-2-alterar-o-raio-do-cilindro","title":"Passo 2 \u00b7 Alterar o Raio do Cilindro","text":"<p>Edite <code>cylinder2d.cpp</code>:</p> <pre><code>// r original\nconst T radiusCylinder = 0.05;   // m\n</code></pre> <pre><code>// exemplo: dobrar o raio\nconst T radiusCylinder = 0.10;   // m\n</code></pre> <p>Recompile e execute:</p> <pre><code>make clean &amp;&amp; make\nmpirun -np 4 ./cylinder2d\n</code></pre> <p>Repita para \u2265 3 valores (0.05, 0.10, 0.15 m\u2026).</p>"},{"location":"cilindro2d/tarefa1/#passo-3-coletar-dados-cilindro","title":"Passo 3 \u00b7 Coletar Dados (Cilindro)","text":"r (m) pressure1 pressure2 \u0394p (Pa) 0.05 0.126632 0.004918 0.12171 0.10 \u2026 \u2026 \u2026 0.15 \u2026 \u2026 \u2026 Como a press\u00e3o varia com o raio? <p>\u0394p \u221d r (arrasto viscoso) ou \u0394p \u221d r\u00b2 (arrasto de forma)?</p> <p>Extra</p> <p>Aumente o n\u00famero de reynolds e veja os v\u00f3rtices se formarem! Note que precisar\u00e1 aumentar o tempo de simula\u00e7\u00e3o!</p>"},{"location":"cilindro2d/tarefa1/#passo-4-trocar-cilindro-por-quadrado","title":"Passo 4 \u00b7 Trocar Cilindro por Quadrado","text":""},{"location":"cilindro2d/tarefa1/#41-defina","title":"4.1 \u00b7 Defina","text":""},{"location":"cilindro2d/tarefa1/#1-parametros-iniciais","title":"1 \u00b7 Par\u00e2metros iniciais","text":"<p>Defina junto com os outros parametros do problema:</p> <pre><code>// --- QUADRADO ---              \u2193 lado em metros\nconst T sideSquare     = 0.10;      // 0.10 m \u00d7 0.10 m\n</code></pre>"},{"location":"cilindro2d/tarefa1/#2-criar-o-obstaculo-dentro-de-main","title":"2 \u00b7 Criar o obst\u00e1culo dentro de <code>main()</code>","text":"<p>Encontre este trecho (quase no fim de <code>main</code>):</p> <pre><code>Vector center{centerCylinderX, centerCylinderY};\nIndicatorCircle2D&lt;T&gt; circle(center, radiusCylinder);\nprepareGeometry(converter, superGeometry, circle);\n\n// === 3rd Step: Prepare Lattice ===\nSuperLattice&lt;T,DESCRIPTOR&gt; sLattice(superGeometry);\nprepareLattice(sLattice, converter, superGeometry, circle);\n</code></pre> <p>Substitua por:</p> <pre><code>Vector center{centerCylinderX, centerCylinderY};\nIndicatorCuboid2D&lt;T&gt; square(sideSquare, sideSquare, center);\nprepareGeometry(converter, superGeometry, square);\n\n// === 3rd Step: Prepare Lattice ===\nSuperLattice&lt;T,DESCRIPTOR&gt; sLattice(superGeometry);\nprepareLattice(sLattice, converter, superGeometry, square);\n</code></pre>"},{"location":"cilindro2d/tarefa1/#3-preparelattice-usar-bounce-back-em-vez-de-bouzidi","title":"3 \u00b7 <code>prepareLattice()</code> \u2014 usar Bounce-Back em vez de Bouzidi","text":"<p>No in\u00edcio de <code>prepareLattice(...)</code>, comente a chamada Bouzidi e adicione Bounce-Back:</p> <pre><code>// Material=5 \u2192 obst\u00e1culo quadrado (bounce-back simples)\nboundary::set&lt;boundary::BounceBack&gt;(sLattice, superGeometry, 5);\n</code></pre>"},{"location":"cilindro2d/tarefa1/#4-executar","title":"4. \u00b7 Executar","text":"<pre><code>make clean &amp;&amp; make\nmpirun -np 4 ./cylinder2d\n</code></pre>"},{"location":"cilindro2d/tarefa1/#passo-5-adicionar-segundo-objeto-quadrado","title":"Passo 5 \u00b7 Adicionar Segundo Objeto (Quadrado)","text":""},{"location":"cilindro2d/tarefa1/#51-declarar-o-novo-obstaculo","title":"5.1 \u00b7 Declarar o novo obst\u00e1culo","text":"<p>No <code>main()</code>, logo depois de criar o primeiro <code>square</code>, adicione:</p> <pre><code>Vector&lt;T,2&gt; center2 {centerCylinderX + 0.2, centerCylinderY}\n// Segundo quadrado deslocado 0.2 m \u00e0 direita\nIndicatorCuboid2D&lt;T&gt; square2(sideSquare, sideSquare,\n                             center2);\n</code></pre>"},{"location":"cilindro2d/tarefa1/#52-preparegeometry-renomear-material","title":"5.2 \u00b7 <code>prepareGeometry()</code> \u2014 renomear material","text":"<p>Na defini\u00e7\u00e3o adicione mais um objeto:</p> <pre><code>void prepareGeometry(const UnitConverter&lt;T, DESCRIPTOR&gt;&amp; converter,\n                     SuperGeometry&lt;T, 2&gt;&amp;                superGeometry,\n                     IndicatorF2D&lt;T&gt;&amp;                    circle,\n                     IndicatorF2D&lt;T&gt;&amp;                    square2)\n</code></pre> <p>Dentro de <code>prepareGeometry(...)</code>, ap\u00f3s a linha que renomeia o primeiro quadrado, adicione:</p> <pre><code>// Material do segundo quadrado\nsuperGeometry.rename(1, 6, square2);   // usa material 6, por exemplo\n</code></pre>"},{"location":"cilindro2d/tarefa1/#53-preparelattice-aplicar-bounce-back","title":"5.3 \u00b7 <code>prepareLattice()</code> \u2014 aplicar Bounce-Back","text":"<p>Logo ap\u00f3s definir o Bounce-Back para o material 5, inclua:</p> <pre><code>// Material=6 \u2192 segundo quadrado (bounce-back)\nboundary::set&lt;boundary::BounceBack&gt;(sLattice, superGeometry, 6);\n</code></pre> Nota <p>Se preferir um c\u00edrculo para o segundo objeto, use   <code>IndicatorCircle2D</code> e troque Bounce-Back por:</p> <p><pre><code>setBouzidiBoundary(sLattice, superGeometry, 6, circle2);\n</code></pre>   Neste caso tr\u00e1 que alterar a defini\u00e7\u00e3o do m\u00e9todo tamb\u00e9m de forma que consiga passar ao segundo circulo!</p>"},{"location":"cilindro2d/tarefa1/#passo-6-executar-e-observar","title":"Passo 6 \u00b7 Executar e Observar","text":"<pre><code>make clean &amp;&amp; make\nmpirun -np 4 ./cylinder2d\n</code></pre> <ul> <li>Voc\u00ea ver\u00e1 <code>pressureDrop</code> no console.</li> <li>No ParaView, note que o segundo quadrado inicialmente n\u00e3o interage se esqueceu de renomear material ou aplicar Bounce-Back.</li> </ul>"},{"location":"cilindro2d/tarefa1/#passo-7-confirmar-interacao","title":"Passo 7 \u00b7 Confirmar Intera\u00e7\u00e3o","text":"<ol> <li>Certifique-se de que ambos materiais (5 e 6) possuam Bounce-Back (ou Bouzidi).</li> <li>Rode novamente e observe a esteira atr\u00e1s de cada obst\u00e1culo.</li> </ol>"},{"location":"cilindro2d/tarefa1b/","title":"Tarefa 1.2 \u2014 Smooth Start-Up do Escoamento","text":"<p>Vamos avaliar como o \u201cramp\u2010up\u201d gradual da velocidade de entrada afeta estabilidade e converg\u00eancia.</p>"},{"location":"cilindro2d/tarefa1b/#passo-1-executar-o-caso-original-ramp-40-do-tempo","title":"Passo 1 \u00b7 Executar o Caso Original (ramp = 40 % do tempo)","text":"<p>Para isso pode copiar o c\u00f3digo original aqui. <pre><code>cd examples/forBeginners/cylinder2d\nmake clean &amp;&amp; make\nmpirun -np 4 ./cylinder2d\n</code></pre></p>"},{"location":"cilindro2d/tarefa1b/#passo-2-remover-o-smooth-start-up","title":"Passo 2 \u00b7 Remover o Smooth Start-Up","text":"<ol> <li>Abra <code>cylinder2d.cpp</code> e encontre, dentro de    <code>void setBoundaryValues(...)</code>, a linha:</li> </ol> <pre><code>T maxVelocity = converter.getCharLatticeVelocity()*3./2.*frac[0];\n</code></pre> <ol> <li>Substitua por:</li> </ol> <pre><code>// --- sem rampa --- velocidade m\u00e1xima j\u00e1 no passo 0\nT maxVelocity = converter.getCharLatticeVelocity()*3./2.;\n</code></pre> <ol> <li>Compile e rode novamente:</li> </ol> <pre><code>make clean &amp;&amp; make\nmpirun -np 4 ./cylinder2d\n</code></pre> <p>Nota</p> <p>Normalmente a simula\u00e7\u00e3o apresenta pico de instabilidade (press\u00e3o oscilando ou at\u00e9 divergindo).</p>"},{"location":"cilindro2d/tarefa1b/#passo-3-smooth-start-de-10-do-tempo","title":"Passo 3 \u00b7 Smooth Start de 10 % do tempo","text":"<p>Volte a linha original do <code>maxVelocity</code> (com <code>*frac[0]</code>).</p> <p>No mesmo bloco, troque:</p> <pre><code>const std::size_t iTmaxStart = converter.getLatticeTime(maxPhysT * 0.4);\n</code></pre> <p>por</p> <pre><code>const std::size_t iTmaxStart = converter.getLatticeTime(maxPhysT * 0.1);\n</code></pre> <p>Compile e rode novamente.</p>"},{"location":"cilindro2d/tarefa1b/#passo-4-smooth-start-de-80-do-tempo","title":"Passo 4 \u00b7 Smooth Start de 80 % do tempo","text":"<p>Troque o mesmo fator para <code>0.8</code>:</p> <pre><code>const std::size_t iTmaxStart = converter.getLatticeTime(maxPhysT * 0.8);\n</code></pre> <p>Compile e rode.</p> Poss\u00edveis Conclus\u00f5es <ul> <li>Sem rampa \u2192 picos de press\u00e3o e poss\u00edvel diverg\u00eancia.</li> <li>Rampa curta (10 %) \u2192 estabiliza r\u00e1pido, mas ainda h\u00e1 overshoot leve.</li> <li>Rampa longa (80 %) \u2192 converg\u00eancia suave, por\u00e9m simula\u00e7\u00e3o \u201cperde tempo\u201d acelerando; escolha depende de robustez desejada \u00d7 custo computacional.</li> </ul>"},{"location":"cilindro2d/tarefa1b/#passo-5-trocar-a-condicao-de-contorno-de-velocidade-pressao","title":"Passo 5 \u00b7 Trocar a Condi\u00e7\u00e3o de Contorno de Velocidade \u2192 Press\u00e3o","text":""},{"location":"cilindro2d/tarefa1b/#51-preparelattice-inflow-como-interpolated-pressure","title":"5.1 \u00b7 <code>prepareLattice()</code> \u2014 inflow como Interpolated Pressure","text":"<p>Substitua uma \u00fanica linha:</p> <p><pre><code>// antes\nboundary::set&lt;boundary::InterpolatedVelocity&gt;(sLattice, superGeometry, 3);\n</code></pre> por <pre><code>// depois\nboundary::set&lt;boundary::InterpolatedPressure&gt;(sLattice, superGeometry, 3);\n</code></pre></p> <p>(o material 3 continua sendo a entrada)</p>"},{"location":"cilindro2d/tarefa1b/#52-setboundaryvalues-functor-de-densidade","title":"5.2 \u00b7 <code>setBoundaryValues()</code> \u2014 functor de densidade (\u03c1)","text":"<p>Logo depois de criar <code>PolynomialStartScale</code> insira:</p> <pre><code>// --- press\u00e3o alvo: 0.1 Pa, suavemente escalonada ---\nAnalyticalConst2D&lt;T,T&gt; rho( converter.getLatticeDensityFromPhysPressure(0.1 * frac[0]) );\n\n// aplica a condi\u00e7\u00e3o de press\u00e3o no inflow (material 3)\nsLattice.defineRho(superGeometry, 3, rho);\n</code></pre> <p>Aviso</p> <p>Remova ou comente a linha que define <code>poiseuilleU</code> (<code>sLattice.defineU(superGeometry, 3, poiseuilleU);</code>) agora a entrada \u00e9 controlada por press\u00e3o, n\u00e3o velocidade.</p>"},{"location":"cilindro2d/tarefa1b/#passo-6-executar-e-comparar","title":"Passo 6 \u00b7 Executar e Comparar","text":"<pre><code>make clean &amp;&amp; make\nmpirun -np 4 ./cylinder2d\n</code></pre>"},{"location":"particulas/","title":"Escoamento em Bifurca\u00e7\u00e3o \u2013 Abordagem Euler-Lagrange","text":"<p>Vis\u00e3o geral Um fluido incompress\u00edvel escoando atrav\u00e9s de uma bifurca\u00e7\u00e3o em regime permanente. As part\u00edculas (fase dispersa) s\u00e3o rastreadas individualmente; quando tocam a parede aderente, s\u00e3o removidas do dom\u00ednio (capture by adhesion).</p>"},{"location":"particulas/#1-formulacao-euler-lagrange","title":"1 \u00b7 Formula\u00e7\u00e3o Euler-Lagrange","text":""},{"location":"particulas/#11-fase-euleriana-fluido","title":"1.1 Fase Euleriana (Fluido)","text":"<ul> <li>Equa\u00e7\u00f5es de Navier\u2013Stokes incomp. em regime permanente   $$     \\nabla\\cdot\\mathbf{u}=0,\\qquad     \\rho(\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p + \\mu\\nabla^2\\mathbf{u}.   $$</li> <li>Condi\u00e7\u00f5es de contorno  </li> <li>Entrada: perfil totalmente desenvolvido ou velocidade m\u00e9dia \\(U_{\\text{in}}\\).  </li> <li>Sa\u00eddas: condi\u00e7\u00e3o de press\u00e3o (\\(p=p_{\\text{ref}}\\)).  </li> <li>Paredes: n\u00e3o-deslizamento \\((\\mathbf{u}=0)\\).</li> </ul> <p>Observa\u00e7\u00e3o: Como o interesse est\u00e1 na din\u00e2mica das part\u00edculas, o campo de escoamento \u00e9 resolvido apenas uma vez, at\u00e9 convergir para o regime permanente \u2014 evitando rec\u00e1lculo a cada time step.</p>"},{"location":"particulas/#12-fase-lagrangiana-particulas","title":"1.2 Fase Lagrangiana (Part\u00edculas)","text":"<p>Para cada part\u00edcula \\(i\\):</p> \\[   m_i\\frac{d\\mathbf{v}_i}{dt} = \\mathbf{F}_{\\text{drag}} + \\mathbf{F}_{\\text{grav}} + \\dots \\] <ul> <li>In\u00e9rcia da part\u00edcula   $$     \\operatorname{St} = \\frac{\\rho_p r_i^2}{18\\mu}\\,\\frac{|\\mathbf{u}|}{L}   $$   determina qu\u00e3o bem a part\u00edcula segue o fluido \u2014 valores altos indicam maior desvio das linhas de corrente.</li> </ul> By Fzigunov - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=115917430"},{"location":"particulas/#2-condicao-de-parede-adesiva","title":"2 \u00b7 Condi\u00e7\u00e3o de Parede Adesiva","text":"<ul> <li>Quando a dist\u00e2ncia centro-parede \\(d_i \\le r_i\\)   \u2192 colis\u00e3o adesiva \u21d2 remover part\u00edcula do dom\u00ednio.  </li> <li>Sem ressalto nem fragmenta\u00e7\u00e3o; part\u00edculas capturadas n\u00e3o retornam ao escoamento.</li> </ul>"},{"location":"particulas/#3-estrategia-numerica","title":"3 \u00b7 Estrat\u00e9gia Num\u00e9rica","text":"<ol> <li> <p>Solver do fluido </p> <ul> <li>Rodar at\u00e9 crit\u00e9rio de converg\u00eancia.  </li> <li>Exportar campo de velocidade em regime permanente \\(\\mathbf{u}(\\mathbf{x})\\).  </li> </ul> </li> <li> <p>Loop temporal da fase dispersa </p> <ul> <li>Para cada time step \\(\\Delta t\\) <ol> <li>Interpolar \\(\\mathbf{u}\\) nas posi\u00e7\u00f5es das part\u00edculas.  </li> <li>Integrar equa\u00e7\u00f5es de movimento.  </li> <li>Verificar colis\u00e3o com parede; remover se aderida.  </li> </ol> </li> </ul> </li> <li> <p>Condi\u00e7\u00e3o de parada </p> <ul> <li>N\u00e3o restam part\u00edculas, ou tempo f\u00edsico m\u00e1ximo alcan\u00e7ado.  </li> </ul> </li> </ol>"},{"location":"particulas/tarefa/","title":"Tarefa","text":""},{"location":"particulas/tarefa/#compilacao-e-execucao-inicial","title":"Compila\u00e7\u00e3o e Execu\u00e7\u00e3o Inicial","text":"<p>Primeiramente, vamos compilar e executar o c\u00f3digo com seus par\u00e2metros padr\u00e3o. Este primeiro passo ir\u00e1 calcular o campo de escoamento do fluido em regime permanente e salv\u00e1-lo em disco. As execu\u00e7\u00f5es futuras carregar\u00e3o este campo, acelerando a simula\u00e7\u00e3o da fase particulada.</p> <ol> <li> <p>Navegue at\u00e9 o diret\u00f3rio do exemplo no seu terminal.     <pre><code>cd examples/particles/bifurcation3d/eulerLagrange\n</code></pre></p> </li> <li> <p>Copie e cole os seguintes comandos para limpar compila\u00e7\u00f5es anteriores, compilar o c\u00f3digo e execut\u00e1-lo em paralelo com 4 processadores:</p> <pre><code>make clean; make\nmpirun -np 4 ./bifurcation3d\n</code></pre> </li> </ol>"},{"location":"particulas/tarefa/#visualizacao-no-paraview","title":"Visualiza\u00e7\u00e3o no ParaView","text":"<ol> <li>Abra o ParaView.</li> <li>Abra o arquivo <code>bifurcation3d.pvd</code> para visualizar o fluido. Clique no bot\u00e3o Apply no painel Properties.</li> <li>Abra tamb\u00e9m o arquivo <code>particles_master.pvd</code> para as part\u00edculas. Clique em Apply.</li> <li>Para visualizar o campo de velocidade, selecione <code>bifurcation3d.pvd</code> no Pipeline Browser e aplique o filtro Slice. No painel Properties do filtro, defina o \"Normal\" como sendo o eixo Y. </li> </ol> Exemplo de visualiza\u00e7\u00e3o de part\u00edculas e linhas de corrente em uma bifurca\u00e7\u00e3o. (Imagem: OpenLB)"},{"location":"particulas/tarefa/#43-modificando-o-raio-e-analisando-o-efeito","title":"4.3 \u00b7 Modificando o Raio e Analisando o Efeito","text":"<p>O n\u00famero de Stokes (\\(St\\)) \u00e9 a principal vari\u00e1vel que dita o comportamento das part\u00edculas. Ele representa a raz\u00e3o entre o tempo caracter\u00edstico de resposta da part\u00edcula e o tempo caracter\u00edstico do escoamento. Conforme definido no c\u00f3digo, ele \u00e9 proporcional ao quadrado do raio da part\u00edcula (\\(r^2\\)):</p> \\[\\operatorname{St} = \\frac{2 \\rho_p r^2 U}{9 \\mu L}\\] <p>Vamos agora testar diferentes raios para observar essa depend\u00eancia.</p>"},{"location":"particulas/tarefa/#tarefa-aumentando-a-inercia-raio-maior","title":"Tarefa : Aumentando a In\u00e9rcia (Raio Maior)","text":"<ol> <li> <p>Modifique o c\u00f3digo: Abra o arquivo <code>bifurcation3d.cpp</code> em um editor de texto. Localize a linha que define o raio e altere o valor para <code>4.0e-4</code>.</p> <pre><code>    // Modifique esta linha\n    const T radius = 4.0e-4;            // particles radius\n</code></pre> </li> <li> <p>Recompile e Execute: Como o arquivo da solu\u00e7\u00e3o do fluido j\u00e1 existe, esta execu\u00e7\u00e3o ser\u00e1 muito mais r\u00e1pida.</p> <pre><code>    make &amp;&amp; mpirun -np 4 ./bifurcation3d\n</code></pre> </li> <li> <p>An\u00e1lise: Visualize o novo <code>particles_master.pvd</code> no ParaView. Observe que, com maior in\u00e9rcia, um n\u00famero significativamente maior de part\u00edculas colide com a parede logo no in\u00edcio da bifurca\u00e7\u00e3o e n\u00e3o consegue passar para as sa\u00eddas. A taxa de escape \u00e9 menor.</p> </li> </ol>"},{"location":"particulas/tarefa/#cenario-3-diminuindo-a-inercia-raio-menor","title":"Cen\u00e1rio 3: Diminuindo a In\u00e9rcia (Raio Menor)","text":"<ol> <li> <p>Modifique o c\u00f3digo: Altere o valor do raio para <code>1.5e-5</code>.</p> <pre><code>// Modifique esta linha\nconst T radius = 1.5e-5;            // particles radius\n</code></pre> </li> <li> <p>Recompile e Execute:</p> <pre><code>make &amp;&amp; mpirun -np 4 ./bifurcation3d\n</code></pre> </li> <li> <p>An\u00e1lise: Visualize os resultados. Com in\u00e9rcia muito baixa, as part\u00edculas seguem as linhas de corrente do fluido de forma muito mais fiel. A maioria das part\u00edculas deve conseguir passar pela bifurca\u00e7\u00e3o, resultando em uma alta taxa de escape, com a divis\u00e3o entre as sa\u00eddas se aproximando da divis\u00e3o do fluxo de massa do pr\u00f3prio fluido.</p> </li> </ol>"},{"location":"setup/prerequisitos/","title":"2. Pr\u00e9-requisitos","text":"<p>Para compilar e executar o exemplo Cylinder2D, certifique-se de ter:</p> <ol> <li>OpenLB instalado e compilado com as bibliotecas necess\u00e1rias (MPI, CUDA, etc.).  </li> <li>Compilador C++20 ou superior (por exemplo, <code>clang 19</code> ou <code>g++ -std=c++20</code>).  </li> <li>O arquivo <code>examples/forBeginners/cylinder2d.cpp</code> deve estar dispon\u00edvel no diret\u00f3rio de trabalho do OpenLB.  </li> </ol> <p>Opcionalmente, para usar GPU ou MPI:</p> <ul> <li>CUDA Toolkit instalado e configurado (se for rodar em GPU).</li> <li>OpenMPI dispon\u00edvel no sistema (se for compilado com suporte MPI).</li> </ul>"},{"location":"setup/setup/","title":"1. Script de Setup (<code>setup.sh</code>)","text":"<p>Para facilitar a compila\u00e7\u00e3o e execu\u00e7\u00e3o, inclua este script na raiz do reposit\u00f3rio:</p> <pre><code>#!/usr/bin/env bash\n# setup.sh\n# --------------------------------------------------------------\n# Automatiza a compila\u00e7\u00e3o do exemplo Cylinder2D no OpenLB\n# --------------------------------------------------------------\n\n#!/usr/bin/env bash\n# install_openlb_wsl.sh\n# --------------------------------------------------------------\n# Installs dependencies and OpenLB on WSL Ubuntu 24.04, including:\n#   \u2022 Linuxbrew + brew-installed Python 3\n#   \u2022 gcc, make, git, OpenMPI, etc.\n#   \u2022 ParaView 6.0.0-RC1 via wget\n#   \u2022 Qt \u201cxcb\u201d dependencies (if Paraview fails to start)\n#   \u2022 Clones OpenLB and applies cpu_gcc_openmpi.mk \u2192 config.mk\n# --------------------------------------------------------------\n\nset -e\nset -o pipefail\n\necho \"==&gt; 1) Update apt repositories...\"\nsudo apt update\n\necho \"==&gt; 2) Install build tools, git, wget, tar, OpenMPI, etc. via apt...\"\nsudo apt install -y \\\n    build-essential \\\n    git \\\n    wget \\\n    tar \\\n    libopenmpi-dev \\\n    openmpi-bin \\\n    cmake \\\n    pkg-config\n\n# ------------------------------------------------------------\n# 3) Install Linuxbrew (if missing) &amp; brew-installed Python 3\n# ------------------------------------------------------------\nif ! command -v brew &gt;/dev/null 2&gt;&amp;1; then\n  echo \"==&gt; Linuxbrew not found\u2014installing now...\"\n  # Install Linuxbrew\n  /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n  # Add brew to PATH in this shell (adjust if your distro uses ~/.bash_profile or ~/.zshrc)\n  echo 'eval \"$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)\"' &gt;&gt; ~/.bashrc\n  eval \"$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)\"\nelse\n  echo \"==&gt; Linuxbrew already installed.\"\nfi\n\necho \"==&gt; 4) Using brew to install Python 3...\"\nsudo apt remove --purge python3\nsudo apt autoremove \nbrew update\nbrew install python3\n\n# Make brew\u2019s python3 the default in this session\neval \"$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)\"\n\n# Confirm\necho \"    \u2022 brew python3 location: $(which python3)\"\necho \"    \u2022 python3 version:       $(python3 --version)\"\necho\n\n# ------------------------------------------------------------\n# 5) Download &amp; Install ParaView 6.0.0-RC1 (via wget)\n# ------------------------------------------------------------\nPARAVIEW_VERSION=\"6.0.0-RC1\"\nPARAVIEW_DIR=\"/opt/paraview/${PARAVIEW_VERSION}\"\nPARAVIEW_TARBALL=\"ParaView-6.0.0-RC1-MPI-Linux-Python3.12-x86_64.tar.gz\"\nPARAVIEW_URL=\"https://www.paraview.org/paraview-downloads/download.php?submit=Download&amp;version=v6.0&amp;type=binary&amp;os=Linux&amp;downloadFile=${PARAVIEW_TARBALL}\"\n\necho \"==&gt; 6) Downloading ParaView ${PARAVIEW_VERSION}...\"\ncd /tmp\n\n# Quote the URL so that '&amp;' isn\u2019t interpreted by bash\nwget -O \"${PARAVIEW_TARBALL}\" \\\n  \"${PARAVIEW_URL}\"\n\necho \"==&gt; 7) Extracting ParaView into ${PARAVIEW_DIR}...\"\nsudo mkdir -p \"${PARAVIEW_DIR}\"\nsudo tar --strip-components=1 -xzf \"${PARAVIEW_TARBALL}\" -C \"${PARAVIEW_DIR}\"\n\necho \"==&gt; 8) Creating symlink /usr/local/bin/paraview \u2192 ${PARAVIEW_DIR}/bin/paraview...\"\nsudo ln -sf \"${PARAVIEW_DIR}/bin/paraview\" /usr/local/bin/paraview\n\necho \"==&gt; 9) Cleaning up temporary tarball...\"\nrm -f \"/tmp/${PARAVIEW_TARBALL}\"\ncd ~\n\n# ------------------------------------------------------------\n# 10) Quick check: try launching `paraview --help`. If it fails,\n#     install the Qt \u201cxcb\u201d plugin dependencies.\n# ------------------------------------------------------------\necho \"==&gt; 10) Verifying ParaView can start (checks for missing Qt plugins)...\"\nif ! paraview --help &gt;/dev/null 2&gt;&amp;1; then\n  echo \"    \u2022 Paraview failed to run \u2192 installing Qt/XCB dependencies via apt...\"\n  sudo apt update\n  sudo apt install -y \\\n    libxcb-cursor0 \\\n    libxcb-keysyms1 \\\n    libxcb-util1 \\\n    libxcb-icccm4 \\\n    libxcb-image0 \\\n    libxcb-render-util0 \\\n    libxcb-render0 \\\n    libxcb-shape0 \\\n    libxcb-sync1 \\\n    libxcb-xfixes0 \\\n    libxcb-xinerama0 \\\n    libxcb-xkb1 \\\n    libxkbcommon-x11-0 \\\n    libx11-xcb1 \\\n    libglu1-mesa \\\n    libgl1-mesa-dri\n  echo \"    \u2022 Qt/XCB dependencies installed.\"\nelse\n  echo \"    \u2022 Paraview launched successfully (Qt plugins OK).\"\nfi\necho\n\n# ------------------------------------------------------------\n# 11) Clone OpenLB repository (if missing) and set config.mk\n# ------------------------------------------------------------\nOPENLB_DIR=\"$HOME/openlb\"\nif [ -d \"${OPENLB_DIR}\" ]; then\n  echo \"==&gt; 11) ${OPENLB_DIR} already exists; skipping clone.\"\nelse\n  echo \"==&gt; 11) Cloning OpenLB into ${OPENLB_DIR}...\"\n  git clone https://gitlab.com/openlb/release.git \"${OPENLB_DIR}\"\nfi\n\necho \"==&gt; 12) Overwriting OpenLB config.mk with cpu_gcc_openmpi.mk...\"\ncp -f \"${OPENLB_DIR}/config/cpu_gcc_openmpi.mk\" \"${OPENLB_DIR}/config.mk\"\n\necho\necho \"=============================================================\"\necho \"OpenLB installation complete!\"\necho\necho \"  \u2022 brew python3:  $(python3 --version)\"\necho \"  \u2022 ParaView:      /usr/local/bin/paraview  (version ${PARAVIEW_VERSION})\"\necho \"  \u2022 OpenMPI:       $(mpicxx --version | head -n1)\"\necho \"  \u2022 OpenLB root:   ${OPENLB_DIR} (using config.mk \u2192 cpu_gcc_openmpi.mk)\"\necho \"=============================================================\"\n</code></pre>"},{"location":"setup/setup/#como-usar-o-setupsh","title":"Como usar o <code>setup.sh</code>","text":"<ol> <li>Copie este conte\u00fado para um arquivo chamado <code>setup.sh</code> na raiz do reposit\u00f3rio.  </li> <li>D\u00ea permiss\u00e3o de execu\u00e7\u00e3o:</li> </ol> <pre><code>chmod +x setup.sh\n</code></pre> <ol> <li>Defina a vari\u00e1vel de ambiente <code>OLB_ROOT</code>:</li> </ol> <pre><code>export OLB_ROOT=\"${HOME}/openlb\"\n</code></pre> <ol> <li>Execute o script:</li> </ol> <pre><code>./setup.sh\n</code></pre> <p>Ele criar\u00e1 o build e o execut\u00e1vel <code>cylinder2d</code> em <code>build/examples/forBeginners/</code>.</p>"}]}